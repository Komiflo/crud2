package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

const (
	outputFilename = "z_crud2.go"
	structTagName  = "crud"
)

type StructType struct {
	TypeSpec   *ast.TypeSpec
	StructType *ast.StructType

	Name             string
	BoundFields      StructFieldList
	EnumeratedFields StructFieldList
}

func (structType StructType) Metadata() string {
	if len(structType.BoundFields) == 0 && len(structType.EnumeratedFields) == 0 {
		return ""
	}

	bs := &bytes.Buffer{}

	var er error
	if len(structType.EnumeratedFields) == 0 {
		er = structTemplateROnly.Execute(bs, structType)
	} else {
		er = structTemplateFull.Execute(bs, structType)
	}
	if er != nil {
		panic(er)
	}

	return bs.String()
}

type StructField struct {
	Name    string
	SqlName string
	Type    ast.Expr
}

func (f StructField) EnumAddr() bool {
	if id, ok := f.Type.(*ast.Ident); ok {
		switch id.Name {
		case "int64":
			return false
		case "string":
			return false
		}
	}

	return true
}

func fileFilter(fi os.FileInfo) bool {
	name := fi.Name()

	if !strings.HasSuffix(name, ".go") {
		return false
	}

	return fi.Name() != outputFilename
}

func contains(s []string, t string) bool {
	for _, e := range s {
		if e == t {
			return true
		}
	}
	return false
}

func buildStructType(structType *StructType, astStruct *ast.StructType, prefix string) {
	for _, field := range astStruct.Fields.List {
		if field.Tag == nil {
			continue
		}

		if len(field.Names) == 0 {
			// XXX: We may want to support anonymous fields in the future.
			continue
		}

		name := field.Names[0].Name

		tagList, er := strconv.Unquote(field.Tag.Value)
		if er != nil {
			continue
		}

		rtags := reflect.StructTag(tagList)

		var nameTag string
		var optionTags []string
		for i, s := range strings.Split(rtags.Get(structTagName), ",") {
			if i == 0 {
				nameTag = s
			} else {
				optionTags = append(optionTags, s)
			}
		}

		if nameTag == "" {
			continue
		}

		if contains(optionTags, "recurse") {
			// The "recurse" flag is valid only on structs, and
			// indicates that all fields of the tagged struct
			// should be included as well.
			// XXX: This is a bit of a mess.
			ident, ok := field.Type.(*ast.Ident)
			if !ok {
				panic("'recurse' Field type is not an ast.Ident?")
			}
			if ident.Obj == nil || ident.Obj.Decl == nil {
				panic("'recurse' Field type doesn't refer to an object")
			}

			ts, ok := ident.Obj.Decl.(*ast.TypeSpec)
			if !ok || ts.Type == nil {
				panic("'recurse' Field type declaration doesn't ... have ... a TypeSpec?")
			}

			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				panic("'recurse' field isn't a struct")
			}

			buildStructType(structType, st, prefix+name+".")
		}

		if !contains(optionTags, "ronly") {
			structType.EnumeratedFields = append(structType.EnumeratedFields, StructField{
				Name:    prefix + name,
				SqlName: nameTag,
				Type:    field.Type,
			})
		}

		structType.BoundFields = append(structType.BoundFields, StructField{
			Name:    prefix + name,
			SqlName: nameTag,
			Type:    field.Type,
		})
	}

	sort.Sort(structType.BoundFields)
	sort.Sort(structType.EnumeratedFields)
}

func main() {
	dirPath := "."

	if len(os.Args) > 1 {
		dirPath = os.Args[1]
	}

	fset := new(token.FileSet)

	pkgs, er := parser.ParseDir(fset, dirPath, fileFilter, 0)
	if er != nil {
		log.Fatal(er)
	}

	structTypes := StructTypeList{}

	if len(pkgs) > 1 {
		log.Fatal("Multiple packages found! crudgen only supports one package at a time.")
	}

	var packageName string

	// Enumerate the AST and pull out all of the struct declarations.
	for _, pkg := range pkgs {
		packageName = pkg.Name

		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					if genDecl.Tok != token.TYPE {
						continue
					}

					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							if structType, ok := typeSpec.Type.(*ast.StructType); ok {
								structTypes = append(structTypes, &StructType{
									TypeSpec:   typeSpec,
									StructType: structType,
									Name:       typeSpec.Name.Name,
								})
							}
						}
					}
				}
			}
		}
	}
	sort.Sort(structTypes)

	// Enumerate the structs we've pulled out and parse their field declarations.
	for _, structType := range structTypes {
		buildStructType(structType, structType.StructType, "")
	}

	filePath := filepath.Join(dirPath, outputFilename)
	f, er := os.Create(filePath)
	if er != nil {
		log.Fatal(er)
	}
	defer f.Close()

	fmt.Fprintf(f, "package %s\n// AUTOGENERATED CODE. Regenerate by running crudgen.\n\nimport crud \"github.com/komiflo/crud2\"\n", packageName)

	for _, structType := range structTypes {
		fmt.Fprintf(f, "%s", structType.Metadata())
	}

	if er := f.Sync(); er != nil {
		log.Fatal(er)
	}
}
